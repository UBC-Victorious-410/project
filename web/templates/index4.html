<!DOCTYPE html>
<meta charset="utf-8">
<style>
.node {
  fill: white;
  stroke: black;
  opacity : 0.75;
}
.link {
  stroke: white;
}
.author {
  fill: white;
  stroke: black;
  opacity : 0.75;
}
</style>
<body bgcolor = #111111>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var width = 2000,
    height = 2000,
    padding = 1.5, // separation between same-color circles
    currentJson = 0,
    AuthCount = 0,
    AuthPos= [{x:(width/2),y:50},
              {x:(width-50),y:(height/2)},
              {x:(width/2),y:(height-50)},
              {x:50,y:(height/2)},
              {x:(3*width/4),y:50},
              {x:(width-50),y:(3*height/4)},
              {x:(width/3),y:(height-50)},
              {x:50,y:(height/3)},
              {x:(width-50),y:(height/3)},
              {x:(3*width/4),y:(height-50)},
              {x:50,y:(height/3)},
              {x:(width/3),y:50}];


var nodes = [];
var links = [];
var authors =[]; 

var force = d3.layout.force()
    .nodes(nodes)
    .size([width, height])
    .gravity(.05)
    .charge(0)
    .on("tick", tick);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("fill", "#111111");

var node = svg.selectAll(".node");
var link = svg.selectAll(".link");
//=========INIT=============
var jsonLoc = "static/"+currentJson+".json"; 
d3.json(jsonLoc, function(json) {
  var Auth_node = {x:AuthPos[0].x, y: AuthPos[0].y,
                   name:json.author,
                   fixed:true,
                   radius:50};
  authors.push(Auth_node);
  
  for (var i = 0; i < json.children.length; i++){
        var violation = 0 ;
        for (var v = 0; v < json.state.length;v++){
          if (json.children[i].name == json.state[v].name){
            violation = json.state[v].size;
          }
        }
        var newClass = {x:width/2,y:height/2,
                        name:json.children[i].name, 
                        radius:scale(json.children[i].size),
                        violation:violation,
                        size:json.children[i].size
                      };
        nodes.push(newClass); 
        
        var newlink = {source:Auth_node,
                       target:newClass,
                       width:1}; 
        links.push(newlink);

  }
});
//=========INIT=============
function tick() {
  node
      .each(collide(.7))
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
      
  link
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; })
      .attr("stroke-width", function(d){
        return (d.target.size > 0 ? d3.select(this).attr("stroke-width"): 0);
      });
}

// Resolves collisions between d and all other circles.
function collide(alpha) {
  var quadtree = d3.geom.quadtree(nodes);
  return function(d) {
    var r = d.radius + padding,
        nx1 = d.x - r,
        nx2 = d.x + r,
        ny1 = d.y - r,
        ny2 = d.y + r;
    quadtree.visit(function(quad, x1, y1, x2, y2) {
      if (quad.point && (quad.point !== d)) {
        var x = d.x - quad.point.x,
            y = d.y - quad.point.y,
            l = Math.sqrt(x * x + y * y),
            r = d.radius + quad.point.radius + padding;
        if (l < r) {
          l = (l - r) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          quad.point.x += x;
          quad.point.y += y;
        }
      }
      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    });
  };
}

function scale(size){
  if (size == 0){
    return 0;
  }else{
    return (size/7 < 5 ? 5 : size/7);
  }
}
function color(violation,size){
  if (violation ==0){
    return "white";
  }
  var ratio = (violation/size)*100;
  if (ratio == 0){
    return "white";
  }else if (ratio > 30){
    return "indigo";
  }else if (ratio > 25){
    return "darkred";
  }else if (ratio > 20){
    return "red";
  }else if (ratio > 15){
    return "orange";
  }else if (ratio > 10){
    return "yellow";
  }else if (ratio > 5){
    return "springgreen";
  }
}


function update(){
  // console.log(nodes);
  if (currentJson == 0){
    node = svg.selectAll(".author")
              .data(authors)
              .enter().insert("circle")
              .attr("cx",  function(d){return d.x})
              .attr("cy",  function(d){return d.y})
              .attr("fixed",function(d){return d.fixed})
              .attr("class", "author")
              .attr("name", function(d){return d.name;})
              .attr("r", function(d){ return d.radius;})
              .append("svg:title")
              .text(function(d){return d.name;})
              .call(force.drag);

    node = svg.selectAll(".node")
              .data(nodes)
              .enter().insert("circle")
              .attr("x",  function(d){return d.x})
              .attr("y",  function(d){return d.y})
              .attr("class", "node")
              .attr("name", function(d){return d.name;})
              .attr("r", function(d){ return d.radius;})
              .append("svg:title")
              .text(function(d){return d.name;})
              .call(force.drag);

    link = svg.selectAll(".link")
              .data(links)
              .enter().insert("line")
              .attr("class", "link")
              .attr("stroke-width", 1);

  force.start();
  }else{
    jsonLoc = "static/"+currentJson+".json"; 
    d3.json(jsonLoc, function(json) {
      for (var j = 0; j <json.children.length;j++){
        var newRadius = scale(json.children[j].size);

        var newViolation = nodes[j].violation;
        for (var v = 0; v < json.state.length;v++){
          if (json.children[j].name == json.state[v].name){
            newViolation = json.state[v].size;
          }
        }
        var newSize = json.children[j].size;

        nodes[j].radius = newRadius;
        nodes[j].violation = newViolation;
        nodes[j].size = newSize;
        }


      node = svg.selectAll(".node")
                .data(nodes)
                .attr("r", function(d){ return d.radius;})
                .style("fill", function(d){return color(d.violation,d.size);})
                .call(force.drag);    
       force.start();         

    });
  }


  currentJson += 1;
  console.log(currentJson);
}

setInterval(update, 2000);
</script>