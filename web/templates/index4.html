<!DOCTYPE html>
<meta charset="utf-8">
<style>
.node {
  fill: white;
  stroke: black;
  opacity : 0.75;
}
</style>
<body bgcolor = #111111>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var width = 2000,
    height = 2000,
    padding = 1.5, // separation between same-color circles
    currentJson = 0;


var nodes = [];
var force = d3.layout.force()
    .nodes(nodes)
    .size([width, height])
    .gravity(.02)
    .charge(0)
    .on("tick", tick);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("fill", "#111111");

var node = svg.selectAll(".node");
var link = svg.selectAll(".link");

var jsonLoc = "static/"+currentJson+".json"; 
d3.json(jsonLoc, function(json) {
  for (var i = 0; i < json.children.length; i++){
        var violation = 0 ;
        for (var v = 0; v < json.state.length;v++){
          if (json.children[i].name = json.state[v].name){
            violation = json.state[v].size;
          }
        }
        var newClass = {name:json.children[i].name, 
                        radius:scale(json.children[i].size),
                        violation:violation,
                        size:json.children[i].size
                      };
        nodes.push(newClass);   
  }
});

function tick() {
  node
      .each(collide(.7))
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
      
  link
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });
}

// Resolves collisions between d and all other circles.
function collide(alpha) {
  var quadtree = d3.geom.quadtree(nodes);
  return function(d) {
    var r = d.radius + padding,
        nx1 = d.x - r,
        nx2 = d.x + r,
        ny1 = d.y - r,
        ny2 = d.y + r;
    quadtree.visit(function(quad, x1, y1, x2, y2) {
      if (quad.point && (quad.point !== d)) {
        var x = d.x - quad.point.x,
            y = d.y - quad.point.y,
            l = Math.sqrt(x * x + y * y),
            r = d.radius + quad.point.radius + padding;
        if (l < r) {
          l = (l - r) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          quad.point.x += x;
          quad.point.y += y;
        }
      }
      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    });
  };
}

function scale(size){
  if (size == 0){
    return 0;
  }else{
    return (size/7 < 5 ? 5 : size/7);
  }
}
function color(violation,size){
  if (violation ==0){
    return "white";
  }
  var ratio = (violation/size)*100;
  if (ratio == 0){
    return "white";
  }else if (ratio > 30){
    return "indigo";
  }else if (ratio > 25){
    return "darkred";
  }else if (ratio > 20){
    return "red";
  }else if (ratio > 15){
    return "orange";
  }else if (ratio > 10){
    return "yellow";
  }else if (ratio > 5){
    return "springgreen";
  }
}


function update(){
  // console.log(nodes);
  if (currentJson == 0){
    node = svg.selectAll(".node")
              .data(nodes)
              .enter().insert("circle")
              .attr("class", "node")
              .attr("name", function(d){return d.name;})
              .attr("r", function(d){ return d.radius;})
              .append("svg:title")
              .text(function(d){return d.name})
              .call(force.drag);

    link = svg.selectAll(".link");
  force.start();
  }else{
    jsonLoc = "static/"+currentJson+".json"; 
    d3.json(jsonLoc, function(json) {
      for (var j = 0; j <json.children.length;j++){
        var newRadius = scale(json.children[j].size);

        var newViolation = nodes[j].violation;
        for (var v = 0; v < json.state.length;v++){
          if (json.children[j].name == json.state[v].name){
            newViolation = json.state[v].size;
          }
        }
        var newSize = json.children[j].size;

        nodes[j].radius = newRadius;
        nodes[j].violation = newViolation;
        nodes[j].size = newSize;
        }


      node = svg.selectAll(".node")
                .data(nodes)
                .attr("r", function(d){ return d.radius;})
                .style("fill", function(d){return color(d.violation,d.size);})
                .call(force.drag);    
       force.start();         

    });
  }


  currentJson += 1;
  console.log(currentJson);
  // var jsonLoc = "static/"+currentJson+".json"; 
  // d3.json(jsonLoc, function(json) {
  // //=============

  // for (var i = 0; i < json.children.length; i++){
  //   var newClass = {x:0,y:0
  //                   // name:json.children[i].name, 
  //                   // class:node,
  //                   // r:scale(json.children[i].size)
  //                 };
  //   // console.log(newClass);
  //   nodes.push(newClass);
  //   node = node.data(nodes);
  //   // console.log(nodes);
  //   node.enter()
  //       .insert("svg:circle")
  //       .attr("class", "node")
  //       .attr("name",json.children[i].name)
  //       .attr("r", scale(json.children[i].size))
  //       .append("svg:title")
  //       .text(json.children[i].name)
  //       .call(force.drag);
  //   }
  


  // //=============
  // force.start();
  // });

  
  // console.log(nodes);
}

setInterval(update, 1000);
</script>